#version 450 core

struct Vertex {
    vec4 position;
    vec4 normal;
};

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct Material {
    vec3 diffuse;
    vec3 emissive;
};

struct IntersectionInfo {
    float t;
    vec3 normal;
    Material mat;
};

const float EPSILON = 1e-4;

layout (local_size_x = 1, local_size_y = 1) in;
layout (rgba32f, binding = 0) uniform image2D oImage;
layout (std430, binding = 1) buffer vertexBuffer
{
    Vertex vertices[];
};

uniform vec2 uResolution;

uniform struct {
    vec3 position;
    vec3 lowerLeft;
    vec3 upperRight;
} uCamera;

uniform int uFrameNumber;

uint rngState = 0;

// https://www.burtleburtle.net/bob/hash/integer.html
uint wangHash() {
    rngState = (rngState ^ 61u) ^ (rngState >> 16);
    rngState = rngState + (rngState << 3);
    rngState = rngState ^ (rngState >> 4);
    rngState = rngState * 0x27d4eb2d;
    rngState = rngState ^ (rngState >> 15);
    return rngState;
}

// Returns a float in range [0, 1)
float random() {
    return float(wangHash()) / 4294967296.0;
}

// NOTE: very very small chance this is a zero vector
vec3 randomUnitVector() {
    return normalize(vec3(random() * 2 - 1, random() * 2 - 1, random() * 2 - 1));
}

// https://en.wikipedia.org/wiki/SRGB
float srgbToLinearComponent(float x) {
	if (x <= 0.04045) return x / 12.92;
	return pow((x + 0.055) / 1.055, 2.4);
}

vec3 srgbToLinear(vec3 x) {
	return vec3(
		srgbToLinearComponent(x.x),
		srgbToLinearComponent(x.y),
		srgbToLinearComponent(x.z)
	);
}

float linearToSrgbComponent(float x) {
    if (x <= 0.0031308) return 12.92 * x;
    return 1.055 * pow(x, 1/2.4) - 0.055;
}

vec3 linearToSrgb(vec3 x) {
    return vec3(
	    linearToSrgbComponent(x.x),
    	linearToSrgbComponent(x.y),
    	linearToSrgbComponent(x.z)
    );
}

// Möller–Trumbore intersection algorithm
IntersectionInfo intersectTriangle(Ray ray, Vertex v0, Vertex v1, Vertex v2, vec3 diffuse, vec3 emissive) {
    IntersectionInfo isect;
    isect.t = -1;

    vec3 e1 = v1.position.xyz - v0.position.xyz;
    vec3 e2 = v2.position.xyz - v0.position.xyz;
    vec3 h = cross(ray.dir, e2);
    float a = dot(e1, h);

    // check if ray is parallel to the triangle
    if (a > -EPSILON && a < EPSILON) {
        return isect;
    }

    // calculate u
    float f = 1.0 / a;
    vec3 s = ray.origin - v0.position.xyz;
    float u = f * dot(s, h);

    // check if u is on triangle
    if (u < 0.0 || u > 1.0) {
        return isect;
    }

    // calculate v
    vec3 q = cross(s, e1);
    float v = f * dot(ray.dir, q);

    // check if v is on triangle
    if (v < 0.0 || u + v > 1.0) {
        return isect;
    }

    // get intersection
    float t = f * dot(e2, q);
    if (t > EPSILON) {
        isect.t = t;

        isect.normal = normalize((u * v0.normal.xyz) + (v * v1.normal.xyz) + ((1 - u - v) * v2.normal.xyz));

        isect.mat.diffuse = diffuse;
        isect.mat.emissive = emissive;
    }

    return isect;
}

IntersectionInfo intersect(Ray ray) {
    IntersectionInfo ret;
    ret.t = -1;

    // TODO: proper material setting

    vec3 white = vec3(0.725, 0.71, 0.68);
    vec3 unlit = vec3(0);
    vec3 lit = vec3(17, 12, 4);

    // TODO: What if a ray hits the back of a triangle?

    for (uint i = 0; i < vertices.length(); i += 3) {
        IntersectionInfo current = intersectTriangle(ray, vertices[i+0], vertices[i+1], vertices[i+2], white, 
            vertices[i].position.y == 1.98 ? lit : unlit);
        if (current.t >= 0 && (current.t < ret.t || ret.t < 0)) {
            ret = current;
        }
    }

    return ret;
}

vec3 trace(Ray ray) {
    vec3 color = vec3(0);
    vec3 throughput = vec3(1);

    const uint numBounces = 5;
    for (int i = 0; i < numBounces; ++i) {
        IntersectionInfo isect = intersect(ray);

        if (isect.t < 0) {
            break;
        }

        vec3 diffuse = isect.mat.diffuse;
        vec3 emissive = isect.mat.emissive;

        // New ray
        ray.origin += ray.dir * isect.t;
        ray.dir = normalize(isect.normal + randomUnitVector());

        // TODO: do math correctly

        color += emissive * throughput;
        throughput *= diffuse;
    }

    return color;
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    // seed rng
    // TODO: better random numbers
    rngState = uint(uint(coord.x) * 1973u + uint(coord.y) * 9277u + uint(uFrameNumber) * 26699u) | 1u;

    // anti-aliasing jitter
    vec2 jitter = vec2(random(), random());
    vec2 uv = vec2(coord + jitter) / uResolution;

    // generate ray
    Ray ray;
    ray.origin = uCamera.position;
    ray.dir    = normalize(mix(uCamera.lowerLeft, uCamera.upperRight, vec3(uv, 0)) - ray.origin);

    // get color from previous frame, change color space to linear
    vec3 color = srgbToLinear(imageLoad(oImage, coord).rgb) * uFrameNumber;

    // trace
    color += trace(ray);

    // average
    color /= float(uFrameNumber + 1);

    // output
    imageStore(oImage, coord, vec4(linearToSrgb(color), 1));
}
